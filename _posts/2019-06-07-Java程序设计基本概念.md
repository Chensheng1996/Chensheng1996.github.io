---
layout: post
title: Java程序设计基本概念
date: 2019-06-07
tags: 面试
---

### JVM
#### **1. ClassLoader基本概念**
<small style="color:orange;font-weight:bold;">
ClassLoader是JVM实现的一部分，ClassLoader包括bootstrap classloader（启动类加载器），ClassLoader在JVM运行的时候加载Java的核心API，以满足Java程序最基本的需求，其中就包括用户定义的ClassLoader，这里所谓的用户定义，是指通过Java程序实现的两个ClassLoader：一个是ExtClassLoader，它的作用是用来加载Java的拓展API，也就是/lib/ext中的类；第二个是AppClassLoader，它是用来加载用户机器上CLASSPATH设置目录中的Class的，通常在没有指定ClassLoader的情况下，程序员自定义的类就由该ClassLoader进行加载。
</small>

#### **2. ClassLoader加载流程**
<small style="color:orange;font-weight:bold;">
当运行一个程序的时候，JVM启动，运行boootstrap classloader，该ClassLoader加载Java核心API（ExtClassLoader和AppClassLoader也在此时被加载），然后调用ExtClassLoader加载拓展API，最后AppClassLoader加载CLASSPATH目录下定义的Class，这就是一个程序最基本的呃加载流程。
</small>
```java
protected synchronized Class loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // 首先检查该name指定的class是否有被加载
    Class c = findLoadedClass(name);
    if(c == null) {
        try {
            if(parent != null) {
                // 如果parent不为null，则调用parent的loadClass进行加载
                c = parent.loadClass(name, false);
            } else {
                // parent为null，则调用parent的BootstrapClassLoader进行加载
                c = findBootstrapClass(name);
            }
        } catch(ClassNotFoundException e) {
            // 如果仍然无法加载成功，则调用自身的findClass进行加载
            c = findClass(name);
        }
    }
    if(resolve) {
        resolveClass(c);
    }
    return c;
}
```

#### **3. 一些重要的方法**
<!-- <small style="color:orange;font-weight:bold;"> -->
- `loadClass()`
- `defineClass()`
- `findSystemClass()`
- `resolveClass()`
- `findLoadedClass()`
- `findClass()`
- `getSystemClassLoader()`
- `forName()`
<!-- </small> -->

### i++

### 类型转换

### 程序结构

### 运算符

### 异常

### 反射